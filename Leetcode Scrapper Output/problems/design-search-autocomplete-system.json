{"tags": [{"duration": "0 - 6 months", "companies": [["0 - 6 months", "Apple\n2"]]}, {"duration": "6 months - 1 year", "companies": [["6 months - 1 year", "Google\n7"], ["6 months - 1 year", "Amazon\n7"], ["6 months - 1 year", "Microsoft\n6"], ["6 months - 1 year", "Lyft\n3"], ["6 months - 1 year", "LinkedIn\n2"]]}, {"duration": "1 year - 2 years", "companies": [["1 year - 2 years", "Twitter\n5"], ["1 year - 2 years", "Uber\n4"], ["1 year - 2 years", "Snapchat\n4"], ["1 year - 2 years", "Bloomberg\n3"], ["1 year - 2 years", "Square\n2"], ["1 year - 2 years", "Adobe\n2"], ["1 year - 2 years", "eBay\n2"], ["1 year - 2 years", "Facebook"]]}], "problem": "<p>Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character <code>'#'</code>).</p>\n\n<p>You are given a string array <code>sentences</code> and an integer array <code>times</code> both of length <code>n</code> where <code>sentences[i]</code> is a previously typed sentence and <code>times[i]</code> is the corresponding number of times the sentence was typed. For each input character except <code>'#'</code>, return the top <code>3</code> historical hot sentences that have the same prefix as the part of the sentence already typed.</p>\n\n<p>Here are the specific rules:</p>\n\n<ul>\n\t<li>The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.</li>\n\t<li>The returned top <code>3</code> hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same hot degree, use ASCII-code order (smaller one appears first).</li>\n\t<li>If less than <code>3</code> hot sentences exist, return as many as you can.</li>\n\t<li>When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.</li>\n</ul>\n\n<p>Implement the <code>AutocompleteSystem</code> class:</p>\n\n<ul>\n\t<li><code>AutocompleteSystem(String[] sentences, int[] times)</code> Initializes the object with the <code>sentences</code> and <code>times</code> arrays.</li>\n\t<li><code>List&lt;String&gt; input(char c)</code> This indicates that the user typed the character <code>c</code>.\n\t<ul>\n\t\t<li>Returns an empty array <code>[]</code> if <code>c == '#'</code> and stores the inputted sentence in the system.</li>\n\t\t<li>Returns the top <code>3</code> historical hot sentences that have the same prefix as the part of the sentence already typed. If there are fewer than <code>3</code> matches, return them all.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre><strong>Input</strong>\n[\"AutocompleteSystem\", \"input\", \"input\", \"input\", \"input\"]\n[[[\"i love you\", \"island\", \"iroman\", \"i love leetcode\"], [5, 3, 2, 2]], [\"i\"], [\" \"], [\"a\"], [\"#\"]]\n<strong>Output</strong>\n[null, [\"i love you\", \"island\", \"i love leetcode\"], [\"i love you\", \"i love leetcode\"], [], []]\n\n<strong>Explanation</strong>\nAutocompleteSystem obj = new AutocompleteSystem([\"i love you\", \"island\", \"iroman\", \"i love leetcode\"], [5, 3, 2, 2]);\nobj.input(\"i\"); // return [\"i love you\", \"island\", \"i love leetcode\"]. There are four sentences that have prefix \"i\". Among them, \"ironman\" and \"i love leetcode\" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, \"i love leetcode\" should be in front of \"ironman\". Also we only need to output top 3 hot sentences, so \"ironman\" will be ignored.\nobj.input(\" \"); // return [\"i love you\", \"i love leetcode\"]. There are only two sentences that have prefix \"i \".\nobj.input(\"a\"); // return []. There are no sentences that have prefix \"i a\".\nobj.input(\"#\"); // return []. The user finished the input, the sentence \"i a\" should be saved as a historical sentence in system. And the following input will be counted as a new search.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == sentences.length</code></li>\n\t<li><code>n == times.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= sentences[i].length &lt;= 100</code></li>\n\t<li><code>1 &lt;= times[i] &lt;= 50</code></li>\n\t<li><code>c</code> is a lowercase English letter, a hash <code>'#'</code>, or space <code>' '</code>.</li>\n\t<li>Each tested sentence will be a sequence of characters <code>c</code> that end with the character <code>'#'</code>.</li>\n\t<li>Each tested sentence will have a length in the range <code>[1, 200]</code>.</li>\n\t<li>The words in each input sentence are separated by single spaces.</li>\n\t<li>At most <code>5000</code> calls will be made to <code>input</code>.</li>\n</ul>\n", "relatedTopics": ["String", "Design", "Trie", "Data Stream"], "similarQuestions": [{"questionName": "Implement Trie (Prefix Tree)", "difficulty": "Medium"}], "problemName": "design-search-autocomplete-system"}